#include "parser.h"
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>

#define MAX_SIZE 1024
#define MAX_PATH 256
#define MAX_HOSTNAME 50
#define MAX_HOME 180
#define HOME "/home/"
typedef struct {
	int pipe[2];
} tPipe ;

/*
-Modificar manipulador para la seÃ±al ctrl+z
*/

void signalDesactivate(int sig){//la terminal no para ante la seÃ±al crtl+c ni ctrl+z
	signal(sig,SIG_IGN);
}

void signalAct(int sig){//si recibe crtl+Z o ctrl+C no se ignora
	signal(sig,SIG_DFL);
}


char *promptFunc(){
	char *string=malloc(1024*sizeof(char));
	char *user=getlogin();
	char *maquina=malloc(MAX_HOSTNAME*sizeof(char));
	char path[MAX_PATH];
	char *home=malloc(MAX_HOME*sizeof(char));//String que contendra /home/user sin necesidad del entorno
	char *punt;
	strcpy(home,HOME);
	strcat(home,user);
	gethostname(maquina,MAX_HOSTNAME);
	if(getcwd(path,MAX_PATH)==NULL){//El path es demasiado grande
		fprintf(stderr,"El path es demasiado grande");
		return NULL;
	};
	punt=strstr(path,home);
	if(punt!=NULL){//el path contiene /home/user por lo que lo sustituimos por ~
		char *aux=malloc(MAX_PATH*sizeof(char));
		char *aux2=malloc(strlen(path)*sizeof(char));
		char *auxFree=aux2;
		strcpy(aux,"\0");
		strcpy(aux2,path);
		strcat(aux,"~");
		aux2=aux2+strlen(home);
		strcat(aux,aux2);
		strcpy(path,aux);
		//Liberamos la memoria reservada
		free(aux);
		free (auxFree);
	}
	strcpy(string,"\0");
	strcat(string,user);
	strcat(string,"@");
	strcat(string,maquina);
	strcat(string,":");
	strcat(string,path);
	strcat(string,"$ \0");
	free(maquina);
	free(home);
	return (char *) string;
}



char *cd (char *ruta){
	int error=0;
	char *home=malloc(MAX_HOME*sizeof(char));
	char rutaAbsoluta[MAX_PATH];
	if(ruta==NULL){//Se retrocede a HOME
		strcpy(home,HOME);
		strcat(home,getlogin());
		strcpy(rutaAbsoluta,home);//cambiar para que no la coja del entorno
	}else if (ruta[0]=='/'){ //Es una ruta absoluta
		strcpy(rutaAbsoluta,ruta);
	} else{//Es una ruta relativa
		getcwd(rutaAbsoluta,MAX_PATH);
		if (strcmp(rutaAbsoluta,"/")!=0){//se hace un cd desde un lugar distinto a la raiz
			strcat(rutaAbsoluta,"/");
		}
		strcat(rutaAbsoluta,ruta);
	}
	error=chdir(rutaAbsoluta);
	if (error!=0){//No se ha podido cambiar de directorio
		fprintf(stderr,"La ruta especificada no existe\n");
		return NULL;

	}
	return (char *)promptFunc(); //La funcion cd no es un hijo la realiza el terminal

}

int *redireccionEntrada(tline *linea){
	int fd;
	if((*linea).redirect_input!=NULL){
		fd=open((*linea).redirect_input,O_RDONLY);
		if (fd==-1){//el fichero no existe
			fprintf(stderr,"%s: no existe el archivo o directorio\n",(*linea).redirect_input);
			exit(1);
		}else{
			dup2(fd,0);
		}
	}
	return 0;
}

int *redireccionSalida(tline *linea){
	int fd;
	if((*linea).redirect_output!=NULL){
		fd=open((*linea).redirect_output,O_WRONLY | O_CREAT | O_TRUNC,0600);
		if (fd==-1){//el fichero no existe
			fprintf(stderr,"%s: fallo al crear el archivo\n",(*linea).redirect_output);
			exit(1);
		}else{
			dup2(fd,1);
		}
	}
	return 0;
}

int *redireccionError(tline *linea){
		int fd;
	if((*linea).redirect_output!=NULL){
		fd=open((*linea).redirect_output,O_WRONLY | O_CREAT | O_TRUNC,0600);
		if (fd==-1){//el fichero no existe
			fprintf(stderr,"%s: fallo al crear el archivo\n",(*linea).redirect_output);
			exit(1);
		}else{
			dup2(fd,2);
		}
	}
	return 0;
}

int unicoMandato(tcommand *mandato,tline *lineaAnalizada,char *prompt){
	int pid;
	char *aux;
	if ((*mandato).filename!=NULL){//Es un programa valido
		pid=fork();
		if (pid==-1){//Error
			fprintf(stderr,"El hijo no se ha creado satisfactoriamente\n");
		}
		if (pid==0){//Proceso hijo
			redireccionEntrada(lineaAnalizada);
			redireccionSalida(lineaAnalizada);
			redireccionError(lineaAnalizada);
			if ((*lineaAnalizada).background!=1){//Si no se ejecuta en background
				signal(SIGINT,signalAct);
				signal(SIGQUIT,signalAct);
			}
			execvp((*mandato).filename,(*mandato).argv);
			fprintf(stderr,"El exec no ha funcionado bien\n");
			exit (1);
		}
		if (pid>0){//Proceso padre
			if((*lineaAnalizada).background){
				waitpid(pid,NULL,WNOWAIT);
			}else{
			waitpid(pid,NULL,0);
			}
		}
	}else if (strcmp((*mandato).argv[0],"cd")==0){//se ejecuta la funcion cd
		if((*mandato).argc==1){//cd sin ruta
			aux=cd(NULL);
		}else{//cd con ruta y solo se coge el primer argumento
			aux=cd((*mandato).argv[1]);
		}
		strcpy(prompt,aux);//se copia el valor del nuevo prompt
		free(aux);//se libera el prompt generado
	}else if (strcmp((*mandato).argv[0],"exit")!=0){
		fprintf(stderr,"%s: no se encontrÃ³ la orden\n",(*mandato).argv[0]);
		return 1;
	}
	return 0;
}

int multiplesMandatos(tcommand *comandos,tline *linea){//Falta redireccion
	int i;
	int j;
	int ncomandos;
	ncomandos=(*linea).ncommands;
	int *pid=(int *)malloc(ncomandos*sizeof(int));
	tcommand *aux;
	tPipe *pipes;//creamos un puntero a un array de dos integer
	tPipe *pipeAux;
	ncomandos=(*linea).ncommands;
	pipes=malloc((ncomandos-1)*sizeof(tPipe));
	for (i=0;i<(ncomandos-1);i++){
		pipeAux=pipes+i;
		pipe((*pipeAux).pipe);
	}
	for (i=0;i<ncomandos;i++){//creacion de n hijos(valor de ncomandos)
		aux=comandos+i;
		pid[i]=fork();
		if (pid[i]==-1){//ha habido un error en la creacion
			fprintf(stderr,"Ha habido un fallo al crear al hijo, no se ejecutara el mandato");
			return 1;
		}else if(pid[i]!=0){//proceso padre

		}else if(pid[i]==0){//proceso hijo i
			if ((*linea).background!=1){//Si no se ejecuta en background
				signal(SIGINT,signalAct);
				signal(SIGQUIT,signalAct);
			}
			if (i!=0){//si no es el primer mandato
				pipeAux=pipes+(i-1);
				dup2((*pipeAux).pipe[0],0);
				close((*pipeAux).pipe[1]);
			}else{//es el primer mandato
				redireccionEntrada(linea);
			}
			if(i!=(ncomandos-1)){//si no es el ultimo mandato
				pipeAux=pipes+i;
				dup2((*pipeAux).pipe[1],1);
				close((*pipeAux).pipe[0]);
			}else{//es el ultimo mandato
				redireccionSalida(linea);
				redireccionError(linea);
			}
			for (j=0;j<(ncomandos-1);j++){//cerrar pipes que no usa
				if (j!=i || j!=(i-1)){
						pipeAux=pipes+j;
						close((*pipeAux).pipe[0]);
						close((*pipeAux).pipe[1]);
				}
			}
			free(pid);//liberamos los pid de cada uno de los hijos
			free(pipes);//liberamos los pipes de cada uno de los hijos
			execvp((*aux).filename,(*aux).argv);
			exit(1);//solo se ejecuta si se ha producido un error
		}

	}
	for (i=0;i<(ncomandos-1);i++){
		pipeAux=pipes+i;
		close((*pipeAux).pipe[0]);
		close((*pipeAux).pipe[1]);
	}
	for (i=0;i<ncomandos;i++){
		if (i!=(ncomandos-1)){
			waitpid(pid[i],NULL,WNOWAIT);
		}else if ((*linea).background){//si se ejecuta en background
			waitpid(pid[i],NULL,WNOWAIT);
		}
		else{
			waitpid(pid[i],NULL,0);
		}
	}
	free(pid);//liberamos la memoria reservada para los pid de los hijos
	free(pipes);//liberamos los pipes del padre
	return 0;
}

int main (int argc,char *argv[]){
	char *prompt;
	char buffer[MAX_SIZE];
	tline *lineaAnalizada;
	tcommand *mandatos;
	signal(SIGINT,signalDesactivate);
	signal(SIGQUIT,signalDesactivate);
	if(argc!=1){
		fprintf(stderr,"No se necesitan argumentos. Uso:%s\n",argv[0]);
		exit(1);
	}
	if (promptFunc()!=NULL){
		prompt=promptFunc();
	}
	do{
		fputs(prompt,stdout);
		fgets(buffer,MAX_SIZE,stdin);
		lineaAnalizada=tokenize(buffer);
		mandatos=(*lineaAnalizada).commands;
		if ((*lineaAnalizada).ncommands==1){
			unicoMandato(mandatos,lineaAnalizada,prompt);
		}else if ((*lineaAnalizada).ncommands>1){
			multiplesMandatos(mandatos,lineaAnalizada);
		}
	}while ((mandatos==NULL) || (strcmp((*mandatos).argv[0],"exit")!=0));//por evaluacion perezosa no hay violacion del segmento
	return 0;
}
